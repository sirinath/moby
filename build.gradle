import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

buildscript {
	ext {
		testng = '7.3.0'
		kotlin_version = '1.4.10'
		kotlin_coroutines  = '1.3.9'
		groovy = '3.0.5'
		scala = '2.13.3'
		ec = '10.4.0'
		log4j2 = '2.8.2'
		conversantmedia_disruptor = '1.2.16'
		freefair = '5.2.1'
		aspectj_version = '1.9.6'
	}
}

plugins {
	id 'base'
	id 'java'
	id 'org.jetbrains.kotlin.jvm' version "$kotlin_version"
	id 'groovy'
	id 'scala'
	id 'io.freefair.aspectj.post-compile-weaving' version "$freefair"
}

description 'Leo Framework'

dependencies {
}

allprojects {
	buildscript {
		repositories {
			mavenLocal()
			gradlePluginPortal()
			mavenCentral()
			google()
			jcenter()
		}

		dependencies {
		}
	}

	group 'io.github.leoframework'
	version '0.0.1-SNAPSHOT'

	apply plugin: 'base'
	apply plugin: 'java'
	apply plugin: 'kotlin'
	apply plugin: 'groovy'
	apply plugin: 'scala'
	apply plugin: 'io.freefair.aspectj.post-compile-weaving'

	apply from: "$rootDir/kotlin.gradle"
	apply from: "$rootDir/groovy.gradle"
	apply from: "$rootDir/scala.gradle"
	apply from: "$rootDir/aspectj.gradle"

	repositories {
		mavenLocal()
		mavenCentral()
		jcenter()
		google()
		gradlePluginPortal()
	}

	test {
		// enable TestNG support (default is JUnit)
		useTestNG() {
			useDefaultListeners = true

			// runlist to executed. path is relative to current folder
			suites 'src/test/resources/testng.xml'
		}

		// turn off Gradle's HTML report to avoid replacing the
		// reports generated by TestNG library
		reports.html.enabled = false

		// set a system property for the test JVM(s)
		// systemProperty 'some.prop', 'value'

		// explicitly include or exclude tests
		// include 'org/foo/**'
		// exclude 'org/boo/**'

		// show standard out and standard error of the test JVM(s) on the console
		testLogging.showStandardStreams = true

		// listen to events in the test execution lifecycle
		beforeTest { descriptor ->
			logger.lifecycle("---")
			logger.lifecycle("# Running test: " + descriptor)
		}

		beforeSuite { suite ->
			logger.lifecycle("===")
			logger.lifecycle("* Running suite: " + suite)
		}

		afterTest { descriptor, result ->
			logger.lifecycle("# Ran test: " + descriptor + " with resutls: " + result)
			logger.lifecycle("---")
		}

		afterSuite { suite, result ->
			logger.lifecycle("* Ran suite: " + suite + " with resutls: " + result)
			logger.lifecycle("===")
		}

		// listen to standard out and standard error of the test JVM(s)
		onOutput { descriptor, event ->
			logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event)
		}

		// Fail the 'test' task on the first test failure
		failFast = false
		ignoreFailures = true

		//we want display the following test events
		testLogging {
			events TestLogEvent.STARTED,
					TestLogEvent.FAILED,
					TestLogEvent.SKIPPED

			exceptionFormat TestExceptionFormat.FULL
			showExceptions true
			showCauses true
			showStackTraces true
			showStandardStreams true

			// set options for log level DEBUG
			debug {
				events TestLogEvent.STARTED,
						TestLogEvent.FAILED,
						TestLogEvent.PASSED,
						TestLogEvent.SKIPPED

				exceptionFormat TestExceptionFormat.FULL
				showExceptions true
				showCauses true
				showStackTraces true
				showStandardStreams true
			}

			info.events = debug.events
			info.exceptionFormat = debug.exceptionFormat
			info.showExceptions = debug.showExceptions
			info.showCauses = debug.showCauses
			info.showStackTraces = debug.showStackTraces
			info.showStandardStreams = debug.showStandardStreams

			warn.events = debug.events
			warn.exceptionFormat = debug.exceptionFormat
			warn.showExceptions = debug.showExceptions
			warn.showCauses = debug.showCauses
			warn.showStackTraces = debug.showStackTraces
			warn.showStandardStreams = debug.showStandardStreams

			error.events = debug.events
			error.exceptionFormat = debug.exceptionFormat
			error.showExceptions = debug.showExceptions
			error.showCauses = debug.showCauses
			error.showStackTraces = debug.showStackTraces
			error.showStandardStreams = debug.showStandardStreams
		}
	}

	java {
		sourceCompatibility = JavaVersion.VERSION_11
		targetCompatibility = JavaVersion.VERSION_11
	}

	tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
		sourceCompatibility = JavaVersion.VERSION_11
		targetCompatibility = JavaVersion.VERSION_11

		kotlinOptions {
			jvmTarget = '11'
			apiVersion = '1.4'
			languageVersion = '1.4'
			javaParameters = true
			useIR = true
		}
	}

	dependencies {
		// NOTE: Do not place your application dependencies here; they belong
		// in the individual module build.gradle files

		implementation group: 'org.eclipse.collections', name: 'eclipse-collections-api', version: "$ec"
		implementation group: 'org.eclipse.collections', name: 'eclipse-collections', version: "$ec"
		implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: "$log4j2"
  		implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: "$log4j2"
		implementation group: 'com.conversantmedia', name: 'disruptor', version: "$conversantmedia_disruptor"

		testImplementation group: 'org.testng', name:'testng', version: "$testng"
	}
}

subprojects {
	buildscript {
		dependencies {
		}
	}

	// NOTE: sub project specific items
	dependencies {
	}
}

wrapper {
	gradleVersion = '6.6.1'
	distributionType = Wrapper.DistributionType.ALL
}